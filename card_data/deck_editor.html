<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>符文战场卡组编辑器</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            padding: 30px;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
            font-size: 2.5em;
        }

        .home-screen {
            text-align: center;
        }

        .button-group {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 50px;
        }

        button {
            padding: 15px 40px;
            font-size: 1.2em;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            font-weight: bold;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .editor-screen {
            display: none;
        }

        .editor-screen.active {
            display: block;
        }

        .section {
            margin-bottom: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .section-title {
            font-size: 1.5em;
            margin-bottom: 15px;
            color: #333;
            border-bottom: 2px solid #667eea;
            padding-bottom: 10px;
        }

        .legend-selector {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .card-preview {
            position: relative;
            cursor: pointer;
            border: 3px solid transparent;
            border-radius: 10px;
            overflow: hidden;
            transition: all 0.3s;
            background: white;
        }

        .card-preview:hover {
            transform: scale(1.05);
            border-color: #667eea;
        }

        .card-preview.selected {
            border-color: #28a745;
            box-shadow: 0 0 15px rgba(40, 167, 69, 0.5);
        }

        .card-preview img {
            width: 100%;
            height: auto;
            display: block;
        }

        .card-name {
            padding: 10px;
            text-align: center;
            font-size: 0.9em;
            background: white;
            font-weight: bold;
        }

        .filters {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }

        .filter-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .filter-group label {
            font-weight: bold;
        }

        select, input {
            padding: 8px 15px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 1em;
        }

        .cards-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        
        /* 战场网格需要更大的空间以容纳旋转后的图片 */
        #battlefieldGrid {
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
        }

        .card-item {
            position: relative;
            cursor: pointer;
            border: 2px solid #ddd;
            border-radius: 8px;
            overflow: hidden;
            transition: all 0.3s;
            background: white;
        }

        .card-item:hover {
            transform: translateY(-5px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        .card-item.selected {
            border-color: #28a745;
            box-shadow: 0 0 10px rgba(40, 167, 69, 0.5);
        }

        .card-item img {
            width: 100%;
            height: auto;
            display: block;
        }

        .card-count {
            position: absolute;
            top: 5px;
            right: 5px;
            background: #28a745;
            color: white;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.9em;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.8);
            overflow: auto;
        }

        .modal.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background: white;
            padding: 20px;
            border-radius: 10px;
            max-width: 90%;
            max-height: 90%;
            position: relative;
        }

        .modal-content img {
            max-width: 100%;
            max-height: 80vh;
            display: block;
            margin: 0 auto;
        }

        .close {
            position: absolute;
            top: 10px;
            right: 20px;
            font-size: 40px;
            font-weight: bold;
            color: #aaa;
            cursor: pointer;
        }

        .close:hover {
            color: #000;
        }

        .deck-summary {
            background: #e9ecef;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .deck-summary h3 {
            margin-bottom: 15px;
            color: #333;
        }

        .summary-item {
            margin: 10px 0;
            font-size: 1.1em;
        }

        .validation-message {
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            font-weight: bold;
        }

        .validation-message.error {
            background: #f8d7da;
            color: #721c24;
            border: 2px solid #f5c6cb;
        }

        .validation-message.success {
            background: #d4edda;
            color: #155724;
            border: 2px solid #c3e6cb;
        }

        .rune-selector {
            display: flex;
            gap: 30px;
            align-items: center;
            margin-top: 15px;
        }

        .rune-item {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .rune-item img {
            width: 100px;
            height: auto;
        }

        .rune-item input {
            width: 80px;
            text-align: center;
        }

        .save-section {
            text-align: center;
            margin-top: 30px;
        }

        .save-section input {
            padding: 12px 20px;
            font-size: 1.1em;
            margin-right: 15px;
            width: 300px;
        }

        .back-button {
            margin-bottom: 20px;
            background: #6c757d;
        }

        .card-info {
            padding: 15px;
            background: white;
            border-radius: 5px;
            margin-top: 10px;
        }

        .card-info p {
            margin: 5px 0;
            font-size: 0.9em;
        }

        .deck-cards-list {
            margin-top: 20px;
            max-height: 500px;
            overflow-y: auto;
        }

        .deck-cards-section {
            margin-top: 20px;
        }

        .deck-cards-section h4 {
            margin-bottom: 10px;
            color: #333;
            font-size: 1.2em;
        }

        .deck-card-item {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 10px;
            margin: 5px 0;
            background: white;
            border-radius: 5px;
            border: 1px solid #ddd;
        }

        .deck-card-item img {
            width: 60px;
            height: auto;
            cursor: pointer;
        }

        .deck-card-item .card-info-text {
            flex: 1;
            font-size: 0.95em;
        }

        .deck-card-item .card-name-text {
            font-weight: bold;
            margin-bottom: 3px;
        }

        .deck-card-item .card-type-text {
            color: #666;
            font-size: 0.85em;
        }

        .deck-card-item input {
            width: 60px;
            text-align: center;
        }

        .deck-card-item .remove-btn {
            padding: 5px 15px;
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9em;
        }

        .deck-card-item .remove-btn:hover {
            background: #c82333;
        }

        /* 战场图片旋转90度 */
        .battlefield-image {
            transform: rotate(90deg);
            transform-origin: center;
        }
        
        /* 确保旋转后的战场容器有足够空间 */
        #battlefieldGrid .card-item {
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: visible !important;
            min-height: 250px;
            min-width: 180px;
            padding: 20px;
        }
        
        /* 战场图片容器，确保旋转后完整显示 */
        #battlefieldGrid .card-item img {
            max-width: 200px;
            max-height: 280px;
            width: auto;
            height: auto;
            object-fit: contain;
        }
        
        /* 摘要中的战场图片也旋转 */
        .battlefield-summary-item img {
            transform: rotate(90deg);
            transform-origin: center;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- 首页 -->
        <div class="home-screen" id="homeScreen">
            <h1>符文战场卡组编辑器</h1>
            <div id="dataLoadSection" style="margin-bottom: 30px;">
                <p style="font-size: 1.1em; margin-bottom: 15px; color: #666;">首先请加载卡牌数据文件</p>
                <input type="file" id="csvFile" accept=".csv" style="display: none;" onchange="loadCSVFile(event)">
                <button onclick="document.getElementById('csvFile').click()">加载卡牌数据 (card_data.csv)</button>
                <div id="dataLoadStatus" style="margin-top: 10px; font-weight: bold;"></div>
                <div style="margin-top: 20px;">
                    <p style="font-size: 1.1em; margin-bottom: 10px; color: #666;">可选：加载英文名称映射表（用于从英文卡表导入）</p>
                    <input type="file" id="englishMapFile" accept=".txt" style="display: none;" onchange="loadEnglishMap(event)">
                    <button onclick="document.getElementById('englishMapFile').click()">加载英文映射表 (id_2_english_name.txt)</button>
                    <div id="englishMapStatus" style="margin-top: 10px; font-weight: bold;"></div>
                </div>
                <div style="margin-top: 20px;">
                    <p style="font-size: 1.1em; margin-bottom: 10px; color: #666;">可选：从英文卡表导入（每行“数量 空格 英文名”）</p>
                    <textarea id="englishDeckInput" placeholder="例如：&#10;1 Daughter of the Void&#10;1 Void Gate&#10;..." style="width: 100%; min-height: 160px; padding: 10px; border: 2px solid #ddd; border-radius: 8px; font-size: 14px;"></textarea>
                    <div style="margin-top: 10px; display: flex; gap: 10px; flex-wrap: wrap;">
                        <button onclick="importFromEnglishList()">从英文卡表导入</button>
                        <button onclick="document.getElementById('englishDeckInput').value=''">清空文本</button>
                    </div>
                    <div id="englishImportMessage" style="margin-top: 10px; font-weight: bold;"></div>
                </div>
            </div>
            <div class="button-group" id="mainButtons" style="display: none;">
                <button onclick="showEditor('create')">创建新卡组</button>
                <button onclick="showEditor('import')">导入卡组</button>
            </div>
            <input type="file" id="importFile" accept=".json" style="display: none;" onchange="importDeck(event)">
        </div>

        <!-- 编辑器页面 -->
        <div class="editor-screen" id="editorScreen">
            <button class="back-button" onclick="backToHome()">返回首页</button>
            
            <!-- 传奇选择 -->
            <div class="section">
                <h2 class="section-title">1. 选择传奇</h2>
                <div class="legend-selector" id="legendSelector"></div>
            </div>

            <!-- 符文选择 -->
            <div class="section" id="runeSection" style="display: none;">
                <h2 class="section-title">2. 选择符文数量</h2>
                <div class="rune-selector" id="runeSelector"></div>
            </div>

            <!-- 战场选择 -->
            <div class="section" id="battlefieldSection" style="display: none;">
                <h2 class="section-title">3. 选择战场</h2>
                <div class="filters">
                    <div class="filter-group">
                        <label>筛选:</label>
                        <select id="battlefieldFilter" onchange="filterBattlefields()">
                            <option value="all">全部</option>
                        </select>
                    </div>
                </div>
                <div class="cards-grid" id="battlefieldGrid"></div>
            </div>

            <!-- 卡牌选择 -->
            <div class="section" id="cardSection" style="display: none;">
                <h2 class="section-title">4. 选择卡牌</h2>
                <div class="filters">
                    <div class="filter-group">
                        <label>颜色筛选:</label>
                        <select id="colorFilter" onchange="filterCards()">
                            <option value="all">全部</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label>类型筛选:</label>
                        <select id="typeFilter" onchange="filterCards()">
                            <option value="all">全部</option>
                            <option value="法术">法术</option>
                            <option value="英雄单位">英雄单位</option>
                            <option value="单位">单位</option>
                            <option value="专属法术">专属法术</option>
                            <option value="专属单位">专属单位</option>
                            <option value="装备">装备</option>
                        </select>
                    </div>
                </div>
                <div class="cards-grid" id="cardsGrid"></div>
            </div>

            <!-- 卡组摘要 -->
            <div class="section" id="summarySection" style="display: none;">
                <h2 class="section-title">5. 卡组摘要</h2>
                <div class="deck-summary" id="deckSummary"></div>
                <div id="validationMessage"></div>
            </div>

            <!-- 保存 -->
            <div class="section" id="saveSection" style="display: none;">
                <h2 class="section-title">6. 保存卡组</h2>
                <div class="save-section">
                    <div style="display: flex; gap: 15px; align-items: center; justify-content: center; flex-wrap: wrap;">
                        <div>
                            <label for="deckName" style="display: block; margin-bottom: 5px; font-weight: bold;">卡组名称:</label>
                            <input type="text" id="deckName" placeholder="输入卡组名称" style="width: 300px;">
                        </div>
                        <div>
                            <label for="fileName" style="display: block; margin-bottom: 5px; font-weight: bold;">文件名:</label>
                            <input type="text" id="fileName" placeholder="输入文件名（不含扩展名）" style="width: 300px;">
                        </div>
                    </div>
                    <button onclick="saveDeck()" style="margin-top: 20px;">保存卡组</button>
                </div>
            </div>
        </div>

        <!-- 卡牌详情模态框 -->
        <div class="modal" id="cardModal" onclick="closeModal()">
            <div class="modal-content" onclick="event.stopPropagation()">
                <span class="close" onclick="closeModal()">&times;</span>
                <img id="modalImage" src="" alt="卡牌详情">
                <div class="card-info" id="modalInfo"></div>
            </div>
        </div>
    </div>

    <script>
        // 全局变量
        let allCards = [];
        let allLegends = [];
        let allRunes = [];
        let allBattlefields = [];
        let currentDeck = {
            legend: null,
            runes: [],
            battlefield: [],
            cards: []
        };
        let selectedLegend = null;
        // 英文名到卡牌ID的映射
        let englishNameToId = new Map();
        let englishNameToIdLower = new Map();

        // 初始化
        window.onload = function() {
            // 不自动加载，等待用户选择文件
        };

        // 加载CSV文件
        function loadCSVFile(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const statusDiv = document.getElementById('dataLoadStatus');
            statusDiv.textContent = '正在加载卡牌数据...';
            statusDiv.style.color = '#666';
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const text = e.target.result;
                    parseCardData(text);
                    statusDiv.textContent = '✓ 卡牌数据加载成功！';
                    statusDiv.style.color = '#28a745';
                    document.getElementById('mainButtons').style.display = 'flex';
                } catch (error) {
                    console.error('加载卡牌数据失败:', error);
                    statusDiv.textContent = '✗ 加载失败: ' + error.message;
                    statusDiv.style.color = '#dc3545';
                }
            };
            reader.onerror = function() {
                statusDiv.textContent = '✗ 读取文件失败';
                statusDiv.style.color = '#dc3545';
            };
            reader.readAsText(file, 'UTF-8');
        }

        // 加载英文名称映射表
        function loadEnglishMap(event) {
            const file = event.target.files[0];
            if (!file) return;
            const statusDiv = document.getElementById('englishMapStatus');
            statusDiv.textContent = '正在加载英文映射表...';
            statusDiv.style.color = '#666';
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const text = e.target.result;
                    parseEnglishMap(text);
                    statusDiv.textContent = '✓ 英文映射表加载成功！';
                    statusDiv.style.color = '#28a745';
                } catch (err) {
                    console.error(err);
                    statusDiv.textContent = '✗ 加载失败: ' + err.message;
                    statusDiv.style.color = '#dc3545';
                }
            };
            reader.onerror = function() {
                statusDiv.textContent = '✗ 读取文件失败';
                statusDiv.style.color = '#dc3545';
            };
            reader.readAsText(file, 'UTF-8');
        }

        // 解析英文映射表文本：每行 "id,English Name(with commas allowed)"
        function parseEnglishMap(text) {
            englishNameToId = new Map();
            englishNameToIdLower = new Map();
            const lines = text.split('\n');
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;
                const firstComma = line.indexOf(',');
                if (firstComma <= 0) continue;
                const id = line.substring(0, firstComma).trim();
                const name = line.substring(firstComma + 1).trim();
                if (!id || !name) continue;
                englishNameToId.set(name, id);
                englishNameToIdLower.set(name.toLowerCase(), id);
            }
        }

        // 从英文卡表导入
        function importFromEnglishList() {
            const msg = document.getElementById('englishImportMessage');
            msg.textContent = '';
            msg.style.color = '#666';

            // 先检查卡牌数据已加载
            if (allCards.length === 0) {
                alert('请先加载卡牌数据文件！');
                return;
            }

            // 提示如果未加载映射表也可以尝试，但成功率会很低
            if (englishNameToId.size === 0) {
                if (!confirm('尚未加载英文映射表，可能无法识别英文名称。是否继续尝试？')) {
                    return;
                }
            }

            const text = document.getElementById('englishDeckInput').value;
            const lines = text.split('\n');
            const errors = [];

            // 重置当前卡组
            currentDeck = { legend: null, runes: [], battlefield: [], cards: [] };
            selectedLegend = null;

            // 暂存计数
            const runeMap = new Map();         // id -> num
            const battlefieldMap = new Map();  // id -> num
            const cardMap = new Map();         // id -> num
            let legendCard = null;

            const getIdByEnglishName = (nameRaw) => {
                const name = nameRaw.trim();
                if (englishNameToId.has(name)) return englishNameToId.get(name);
                const lower = name.toLowerCase();
                if (englishNameToIdLower.has(lower)) return englishNameToIdLower.get(lower);
                return null;
            };

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;
                const m = line.match(/^(\d+)\s+(.+)$/);
                if (!m) {
                    errors.push(`第${i + 1}行格式不正确: "${line}"`);
                    continue;
                }
                const num = parseInt(m[1], 10);
                const engName = m[2].trim();
                if (!num || num <= 0) continue;

                const id = getIdByEnglishName(engName);
                if (!id) {
                    errors.push(`未找到英文名对应的卡牌: "${engName}"`);
                    continue;
                }

                // 在已加载卡牌中查找该ID的完整信息
                const card = allCards.find(c => c.card_id.toLowerCase() === id.toLowerCase());
                if (!card) {
                    errors.push(`映射到ID "${id}" 的卡牌未在卡牌数据中找到`);
                    continue;
                }

                if (card.card_type === '传奇') {
                    // 传奇按规则应为1张，若输入>1，默认按1张
                    if (!legendCard) {
                        legendCard = { ...card, num: 1 };
                    }
                } else if (card.card_type === '符文') {
                    runeMap.set(card.card_id, (runeMap.get(card.card_id) || 0) + num);
                } else if (card.card_type === '战场') {
                    battlefieldMap.set(card.card_id, Math.min(3, (battlefieldMap.get(card.card_id) || 0) + num));
                } else {
                    cardMap.set(card.card_id, Math.min(3, (cardMap.get(card.card_id) || 0) + num));
                }
            }

            // 写入当前卡组
            if (legendCard) {
                currentDeck.legend = legendCard;
                selectedLegend = allLegends.find(l => l.card_id === legendCard.card_id) || legendCard;
            }
            // 符文
            runeMap.forEach((num, id) => {
                const rune = allRunes.find(r => r.card_id === id);
                if (rune) currentDeck.runes.push({ ...rune, num });
            });
            // 战场
            battlefieldMap.forEach((num, id) => {
                const battlefield = allBattlefields.find(b => b.card_id === id);
                if (battlefield) currentDeck.battlefield.push({ ...battlefield, num });
            });
            // 其他卡牌
            cardMap.forEach((num, id) => {
                const found = allCards.find(c => c.card_id === id);
                if (found && found.card_type !== '传奇' && found.card_type !== '符文' && found.card_type !== '战场') {
                    currentDeck.cards.push({ ...found, num });
                }
            });

            // 进入编辑页并渲染
            document.getElementById('homeScreen').style.display = 'none';
            document.getElementById('editorScreen').classList.add('active');
            renderLegends();
            renderRunes();
            renderBattlefields();
            renderCards();
            updateSummary();
            document.getElementById('runeSection').style.display = 'block';
            document.getElementById('battlefieldSection').style.display = 'block';
            document.getElementById('cardSection').style.display = 'block';
            document.getElementById('summarySection').style.display = 'block';
            document.getElementById('saveSection').style.display = 'block';

            if (errors.length > 0) {
                msg.style.color = '#dc3545';
                msg.innerHTML = '部分条目未能导入：<br>' + errors.join('<br>');
            } else {
                msg.style.color = '#28a745';
                msg.textContent = '✓ 英文卡表导入完成';
            }
        }
        // 解析卡牌数据
        function parseCardData(text) {
            // 清空之前的数据
            allCards = [];
            allLegends = [];
            allRunes = [];
            allBattlefields = [];
            
            const lines = text.split('\n');
            const headers = lines[0].split(',');
            
            for (let i = 1; i < lines.length; i++) {
                if (!lines[i].trim()) continue;
                
                const values = parseCSVLine(lines[i]);
                if (values.length < headers.length) continue;
                
                const card = {
                    card_id: values[0],
                    card_name: values[1],
                    series: values[2],
                    color: parseColors(values[3]),
                    cost: values[4] || '',
                    energy: values[5] || '',
                    card_type: values[6],
                    power: values[7] || '',
                    legend: values[8] || '',
                    rule: values[9] || ''
                };
                
                allCards.push(card);
                
                if (card.card_type === '传奇') {
                    allLegends.push(card);
                } else if (card.card_type === '符文') {
                    allRunes.push(card);
                } else if (card.card_type === '战场') {
                    allBattlefields.push(card);
                }
            }
            
            // 如果已经有选中的传奇，重新渲染
            if (selectedLegend) {
                renderLegends();
            }
        }

        // 解析CSV行（处理引号内的逗号）
        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;
            
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    // 去除字段值两端的引号
                    let value = current.trim();
                    if (value.startsWith('"') && value.endsWith('"')) {
                        value = value.slice(1, -1);
                    }
                    result.push(value);
                    current = '';
                } else {
                    current += char;
                }
            }
            // 处理最后一个字段
            let value = current.trim();
            if (value.startsWith('"') && value.endsWith('"')) {
                value = value.slice(1, -1);
            }
            result.push(value);
            return result;
        }

        // 解析颜色
        function parseColors(colorStr) {
            if (!colorStr) return [];
            return colorStr.split(',').map(c => c.trim()).filter(c => c);
        }

        // 显示编辑器
        function showEditor(mode) {
            if (mode === 'import') {
                document.getElementById('importFile').click();
                return;
            }
            
            // 检查是否已加载数据
            if (allCards.length === 0) {
                alert('请先加载卡牌数据文件！');
                return;
            }
            
            document.getElementById('homeScreen').style.display = 'none';
            document.getElementById('editorScreen').classList.add('active');
            renderLegends();
        }

        // 导入卡组
        function importDeck(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            // 检查是否已加载数据
            if (allCards.length === 0) {
                alert('请先加载卡牌数据文件！');
                document.getElementById('importFile').value = '';
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const deck = JSON.parse(e.target.result);
                    currentDeck = {
                        legend: deck.legend,
                        runes: deck.runes || [],
                        battlefield: deck.battlefield || [],
                        cards: deck.cards || []
                    };
                    
                    // 从卡组中找到对应的传奇对象
                    if (deck.legend) {
                        selectedLegend = allLegends.find(l => l.card_id === deck.legend.card_id);
                        if (!selectedLegend) {
                            // 如果找不到，使用导入的数据
                            selectedLegend = deck.legend;
                            // 处理 legend_belongto 字段，转换为内部使用的格式
                            if (deck.legend.legend_belongto) {
                                selectedLegend.legend = deck.legend.legend_belongto;
                                selectedLegend['所属传奇'] = deck.legend.legend_belongto;
                            }
                        } else {
                            // 如果找到了，确保保留导入数据中的"所属传奇"字段（如果存在）
                            if (deck.legend.legend_belongto) {
                                selectedLegend.legend = deck.legend.legend_belongto;
                                selectedLegend['所属传奇'] = deck.legend.legend_belongto;
                            } else if (deck.legend['所属传奇']) {
                                selectedLegend['所属传奇'] = deck.legend['所属传奇'];
                            }
                        }
                    }
                    
                    // 处理卡牌中的 legend_belongto 字段
                    if (currentDeck.cards) {
                        currentDeck.cards.forEach(card => {
                            if (card.legend_belongto) {
                                card.legend = card.legend_belongto;
                                card['所属传奇'] = card.legend_belongto;
                            }
                        });
                    }
                    
                    document.getElementById('homeScreen').style.display = 'none';
                    document.getElementById('editorScreen').classList.add('active');
                    
                    renderLegends();
                    renderRunes();
                    renderBattlefields();
                    renderCards();
                    updateSummary();
                    
                    // 设置卡组名称和文件名
                    if (deck.deck_name) {
                        document.getElementById('deckName').value = deck.deck_name;
                        // 默认使用 deck_name 作为文件名，但用户可以修改
                        document.getElementById('fileName').value = deck.deck_name;
                    }
                    
                    // 显示所有相关部分
                    document.getElementById('runeSection').style.display = 'block';
                    document.getElementById('battlefieldSection').style.display = 'block';
                    document.getElementById('cardSection').style.display = 'block';
                    document.getElementById('summarySection').style.display = 'block';
                    document.getElementById('saveSection').style.display = 'block';
                } catch (error) {
                    alert('导入卡组失败: ' + error.message);
                }
            };
            reader.readAsText(file);
        }

        // 返回首页
        function backToHome() {
            document.getElementById('homeScreen').style.display = 'block';
            document.getElementById('editorScreen').classList.remove('active');
            currentDeck = { legend: null, runes: [], battlefield: [], cards: [] };
            selectedLegend = null;
            // 重置文件输入
            document.getElementById('importFile').value = '';
        }

        // 渲染传奇
        function renderLegends() {
            const container = document.getElementById('legendSelector');
            container.innerHTML = '';
            
            allLegends.forEach(legend => {
                const isSelected = selectedLegend && selectedLegend.card_id === legend.card_id;
                const div = document.createElement('div');
                div.className = 'card-preview' + (isSelected ? ' selected' : '');
                // 如果已选择，点击打开详情；如果未选择，点击选择
                div.onclick = () => {
                    if (isSelected) {
                        showCardDetail(legend);
                    } else {
                        selectLegend(legend);
                    }
                };
                // 右键取消选择
                div.oncontextmenu = (e) => {
                    e.preventDefault();
                    if (isSelected) {
                        selectedLegend = null;
                        currentDeck.legend = null;
                        currentDeck.runes = [];
                        currentDeck.cards = [];
                        currentDeck.battlefield = [];
                        renderLegends();
                        document.getElementById('runeSection').style.display = 'none';
                        document.getElementById('battlefieldSection').style.display = 'none';
                        document.getElementById('cardSection').style.display = 'none';
                        updateSummary();
                    }
                };
                
                const img = document.createElement('img');
                img.src = getImagePath(legend.card_id);
                img.onerror = () => { img.src = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="280"><rect fill="%23ccc" width="200" height="280"/><text x="50%25" y="50%25" text-anchor="middle" dy=".3em">无图片</text></svg>'; };
                
                const name = document.createElement('div');
                name.className = 'card-name';
                name.textContent = legend.card_name;
                
                div.appendChild(img);
                div.appendChild(name);
                container.appendChild(div);
            });
        }

        // 选择传奇
        function selectLegend(legend) {
            selectedLegend = legend;
            currentDeck.legend = { ...legend, num: 1 };
            currentDeck.cards = [];
            currentDeck.battlefield = [];
            
            // 初始化符文：两种符文各为6
            currentDeck.runes = [];
            const legendColors = legend.color;
            const availableRunes = allRunes.filter(rune => 
                rune.color.length === 1 && legendColors.includes(rune.color[0])
            );
            
            legendColors.forEach(color => {
                const runes = availableRunes.filter(r => r.color[0] === color);
                if (runes.length > 0) {
                    const rune = runes[0];
                    currentDeck.runes.push({ ...rune, num: 6 });
                }
            });
            
            renderLegends();
            renderRunes();
            renderBattlefields();
            renderCards();
            
            document.getElementById('runeSection').style.display = 'block';
        }

        // 渲染符文
        function renderRunes() {
            if (!selectedLegend) return;
            
            const container = document.getElementById('runeSelector');
            container.innerHTML = '';
            
            const legendColors = selectedLegend.color;
            const availableRunes = allRunes.filter(rune => 
                rune.color.length === 1 && legendColors.includes(rune.color[0])
            );
            
            legendColors.forEach(color => {
                const runes = availableRunes.filter(r => r.color[0] === color);
                if (runes.length === 0) return;
                
                // 优先使用已选择的符文，否则使用第一个匹配的符文
                let rune = currentDeck.runes.find(r => r.color[0] === color);
                if (!rune) {
                    rune = runes[0];
                }
                
                const div = document.createElement('div');
                div.className = 'rune-item';
                
                const img = document.createElement('img');
                img.src = getImagePath(rune.card_id);
                img.onerror = () => { img.src = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="140"><rect fill="%23ccc"/></svg>'; };
                img.onclick = () => showCardDetail(rune);
                
                const input = document.createElement('input');
                input.type = 'number';
                input.min = '0';
                input.max = '12';
                input.value = getRuneCount(color);
                input.onchange = (e) => {
                    const newValue = parseInt(e.target.value) || 0;
                    updateRuneCount(rune, newValue);
                };
                
                const label = document.createElement('label');
                label.textContent = rune.card_name;
                
                div.appendChild(img);
                div.appendChild(label);
                div.appendChild(input);
                container.appendChild(div);
            });
        }

        // 获取符文数量
        function getRuneCount(color) {
            const rune = currentDeck.runes.find(r => r.color[0] === color);
            return rune ? rune.num : 6; // 默认返回6
        }

        // 更新符文数量
        function updateRuneCount(rune, count) {
            // 确保count在0-12之间
            count = Math.max(0, Math.min(12, count));
            
            const currentColor = rune.color[0];
            const legendColors = selectedLegend.color;
            const otherColor = legendColors.find(c => c !== currentColor);
            
            // 找到当前符文和另一种符文
            const currentRuneIndex = currentDeck.runes.findIndex(r => r.card_id === rune.card_id);
            const otherRune = currentDeck.runes.find(r => r.color[0] === otherColor);
            
            // 计算另一种符文应该的数量（总和为12）
            const otherCount = 12 - count;
            
            // 更新当前符文
            if (count > 0) {
                const runeData = { ...rune, num: count };
                if (currentRuneIndex >= 0) {
                    currentDeck.runes[currentRuneIndex] = runeData;
                } else {
                    currentDeck.runes.push(runeData);
                }
            } else {
                if (currentRuneIndex >= 0) {
                    currentDeck.runes.splice(currentRuneIndex, 1);
                }
            }
            
            // 更新另一种符文
            if (otherRune) {
                const otherRuneIndex = currentDeck.runes.findIndex(r => r.card_id === otherRune.card_id);
                if (otherCount > 0) {
                    const otherRuneData = { ...otherRune, num: otherCount };
                    if (otherRuneIndex >= 0) {
                        currentDeck.runes[otherRuneIndex] = otherRuneData;
                    } else {
                        currentDeck.runes.push(otherRuneData);
                    }
                } else {
                    if (otherRuneIndex >= 0) {
                        currentDeck.runes.splice(otherRuneIndex, 1);
                    }
                }
            } else if (otherCount > 0 && otherColor) {
                // 如果另一种符文不存在，需要创建它
                const availableRunes = allRunes.filter(r => 
                    r.color.length === 1 && r.color[0] === otherColor
                );
                if (availableRunes.length > 0) {
                    const newRune = availableRunes[0];
                    currentDeck.runes.push({ ...newRune, num: otherCount });
                }
            }
            
            // 重新渲染符文以更新输入框的值
            renderRunes();
            updateSummary();
        }

        // 渲染战场
        function renderBattlefields() {
            const container = document.getElementById('battlefieldGrid');
            container.innerHTML = '';
            
            allBattlefields.forEach(battlefield => {
                const count = getCardCount(currentDeck.battlefield, battlefield.card_id);
                const isSelected = count > 0;
                const div = document.createElement('div');
                div.className = 'card-item' + (isSelected ? ' selected' : '');
                // 如果已选择，点击打开详情；如果未选择，点击选择
                div.onclick = () => {
                    if (isSelected) {
                        showCardDetail(battlefield);
                    } else {
                        toggleBattlefield(battlefield);
                    }
                };
                // 右键取消选择
                div.oncontextmenu = (e) => {
                    e.preventDefault();
                    if (isSelected) {
                        const index = currentDeck.battlefield.findIndex(b => b.card_id === battlefield.card_id);
                        if (index >= 0) {
                            currentDeck.battlefield.splice(index, 1);
                            renderBattlefields();
                            updateSummary();
                        }
                    }
                };
                
                const img = document.createElement('img');
                img.className = 'battlefield-image';
                img.src = getImagePath(battlefield.card_id);
                img.onerror = () => { img.src = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="180" height="252"><rect fill="%23ccc"/></svg>'; };
                
                if (count > 0) {
                    const countBadge = document.createElement('div');
                    countBadge.className = 'card-count';
                    countBadge.textContent = count;
                    div.appendChild(countBadge);
                }
                
                div.appendChild(img);
                container.appendChild(div);
            });
            
            document.getElementById('battlefieldSection').style.display = 'block';
        }

        // 切换战场
        function toggleBattlefield(battlefield) {
            const index = currentDeck.battlefield.findIndex(b => b.card_id === battlefield.card_id);
            if (index >= 0) {
                const current = currentDeck.battlefield[index];
                if (current.num >= 3) {
                    currentDeck.battlefield.splice(index, 1);
                } else {
                    current.num++;
                }
            } else {
                currentDeck.battlefield.push({ ...battlefield, num: 1 });
            }
            renderBattlefields();
            updateSummary();
        }

        // 渲染卡牌
        function renderCards() {
            if (!selectedLegend) return;
            
            const legendColors = selectedLegend.color;
            const legendName = selectedLegend.legend || selectedLegend['所属传奇'] || selectedLegend.card_name.split('-')[0];
            
            const availableCards = allCards.filter(card => {
                if (card.card_type === '传奇' || card.card_type === '符文' || card.card_type === '战场') {
                    return false;
                }
                
                // 专属卡牌必须匹配传奇
                if (card.card_type === '专属法术' || card.card_type === '专属单位') {
                    const cardLegend = card.legend || card['所属传奇'];
                    return cardLegend === legendName;
                }
                
                // 其他卡牌颜色必须匹配
                if (card.color.length === 1) {
                    return legendColors.includes(card.color[0]);
                } else if (card.color.length === 2) {
                    return card.color.every(c => legendColors.includes(c));
                }
                
                return false;
            });
            
            currentDisplayedCards = availableCards;
            
            // 更新筛选器选项
            updateFilters(availableCards);
            
            // 渲染卡牌列表
            renderCardsList(availableCards);
            
            document.getElementById('cardSection').style.display = 'block';
        }

        // 更新筛选器
        function updateFilters(cards) {
            const colorFilter = document.getElementById('colorFilter');
            const colors = new Set();
            cards.forEach(card => card.color.forEach(c => colors.add(c)));
            
            colorFilter.innerHTML = '<option value="all">全部</option>';
            ['红色', '蓝色', '绿色', '黄色', '橙色', '紫色'].forEach(color => {
                if (colors.has(color)) {
                    const option = document.createElement('option');
                    option.value = color;
                    option.textContent = color;
                    colorFilter.appendChild(option);
                }
            });
        }

        // 存储当前显示的卡牌列表
        let currentDisplayedCards = [];

        // 筛选卡牌
        function filterCards() {
            if (!selectedLegend) return;
            
            const colorFilter = document.getElementById('colorFilter').value;
            const typeFilter = document.getElementById('typeFilter').value;
            
            const legendColors = selectedLegend.color;
            const legendName = selectedLegend.legend || selectedLegend['所属传奇'] || selectedLegend.card_name.split('-')[0];
            
            const availableCards = allCards.filter(card => {
                if (card.card_type === '传奇' || card.card_type === '符文' || card.card_type === '战场') {
                    return false;
                }
                
                // 专属卡牌必须匹配传奇
                if (card.card_type === '专属法术' || card.card_type === '专属单位') {
                    const cardLegend = card.legend || card['所属传奇'];
                    if (cardLegend !== legendName) return false;
                } else {
                    // 其他卡牌颜色必须匹配
                    if (card.color.length === 1) {
                        if (!legendColors.includes(card.color[0])) return false;
                    } else if (card.color.length === 2) {
                        if (!card.color.every(c => legendColors.includes(c))) return false;
                    }
                }
                
                // 应用筛选
                const colorMatch = colorFilter === 'all' || card.color.includes(colorFilter);
                const typeMatch = typeFilter === 'all' || card.card_type === typeFilter;
                
                return colorMatch && typeMatch;
            });
            
            currentDisplayedCards = availableCards;
            renderCardsList(availableCards);
        }
        
        // 渲染卡牌列表
        function renderCardsList(cards) {
            const container = document.getElementById('cardsGrid');
            container.innerHTML = '';
            
            cards.forEach(card => {
                const count = getCardCount(currentDeck.cards, card.card_id);
                const isSelected = count > 0;
                const div = document.createElement('div');
                div.className = 'card-item' + (isSelected ? ' selected' : '');
                
                // 用于区分单击和双击的定时器
                let clickTimer = null;
                
                // 单击事件：未选择时选择，已选择时增加数量
                div.onclick = () => {
                    if (clickTimer) {
                        clearTimeout(clickTimer);
                        clickTimer = null;
                        // 这是双击，打开详情页
                        showCardDetail(card);
                        return;
                    }
                    
                    // 单击处理
                    clickTimer = setTimeout(() => {
                        clickTimer = null;
                        if (isSelected) {
                            // 已选择：增加数量
                            const index = currentDeck.cards.findIndex(c => c.card_id === card.card_id);
                            if (index >= 0) {
                                const current = currentDeck.cards[index];
                                if (current.num < 3) {
                                    current.num++;
                                    // 保持筛选状态，只重新渲染列表而不重新筛选
                                    renderCardsList(currentDisplayedCards);
                                    updateSummary();
                                }
                            }
                        } else {
                            // 未选择：添加到卡组
                            toggleCard(card);
                        }
                    }, 250); // 250ms内再次点击视为双击
                };
                
                // 右键取消选择
                div.oncontextmenu = (e) => {
                    e.preventDefault();
                    if (clickTimer) {
                        clearTimeout(clickTimer);
                        clickTimer = null;
                    }
                    if (isSelected) {
                        const index = currentDeck.cards.findIndex(c => c.card_id === card.card_id);
                        if (index >= 0) {
                            currentDeck.cards.splice(index, 1);
                            // 保持筛选状态，只重新渲染列表而不重新筛选
                            renderCardsList(currentDisplayedCards);
                            updateSummary();
                        }
                    }
                };
                
                const img = document.createElement('img');
                img.src = getImagePath(card.card_id);
                img.onerror = () => { img.src = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="180" height="252"><rect fill="%23ccc"/></svg>'; };
                
                if (count > 0) {
                    const countBadge = document.createElement('div');
                    countBadge.className = 'card-count';
                    countBadge.textContent = count;
                    div.appendChild(countBadge);
                }
                
                div.appendChild(img);
                container.appendChild(div);
            });
        }

        // 筛选战场
        function filterBattlefields() {
            // 战场筛选功能可以后续扩展
        }

        // 切换卡牌
        function toggleCard(card) {
            const index = currentDeck.cards.findIndex(c => c.card_id === card.card_id);
            if (index >= 0) {
                const current = currentDeck.cards[index];
                if (current.num >= 3) {
                    currentDeck.cards.splice(index, 1);
                } else {
                    current.num++;
                }
            } else {
                currentDeck.cards.push({ ...card, num: 1 });
            }
            // 保持筛选状态，只重新渲染列表而不重新筛选
            renderCardsList(currentDisplayedCards);
            updateSummary();
        }

        // 获取卡牌数量
        function getCardCount(cardList, cardId) {
            const card = cardList.find(c => c.card_id === cardId);
            return card ? card.num : 0;
        }

        // 显示卡牌详情
        function showCardDetail(card) {
            const modal = document.getElementById('cardModal');
            const img = document.getElementById('modalImage');
            const info = document.getElementById('modalInfo');
            
            img.src = getImagePath(card.card_id);
            img.onerror = () => { img.src = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="400" height="560"><rect fill="%23ccc"/></svg>'; };
            
            // 如果是战场，添加旋转class
            if (card.card_type === '战场') {
                img.className = 'battlefield-image';
            } else {
                img.className = '';
            }
            
            info.innerHTML = `
                <p><strong>名称:</strong> ${card.card_name}</p>
                <p><strong>类型:</strong> ${card.card_type}</p>
                <p><strong>颜色:</strong> ${card.color.join(', ') || '无'}</p>
                ${card.cost ? `<p><strong>费用:</strong> ${card.cost}</p>` : ''}
                ${card.energy ? `<p><strong>符能:</strong> ${card.energy}</p>` : ''}
                ${card.power ? `<p><strong>战力:</strong> ${card.power}</p>` : ''}
                ${card.legend ? `<p><strong>所属传奇:</strong> ${card.legend}</p>` : ''}
                ${card.rule ? `<p><strong>规则:</strong> ${card.rule}</p>` : ''}
            `;
            
            modal.classList.add('active');
        }
        
        // 通过ID显示卡牌详情（用于摘要中的点击）
        function showCardDetailById(cardId, type) {
            let card = null;
            if (type === 'rune') {
                card = allRunes.find(r => r.card_id === cardId);
            } else if (type === 'battlefield') {
                card = allBattlefields.find(b => b.card_id === cardId);
            } else {
                card = allCards.find(c => c.card_id === cardId);
            }
            if (card) {
                showCardDetail(card);
            }
        }

        // 关闭模态框
        function closeModal() {
            document.getElementById('cardModal').classList.remove('active');
        }

        // 获取图片路径
        function getImagePath(cardId) {
            // 处理不同的命名格式
            const lowerId = cardId.toLowerCase();
            // 如果是OGS系列，使用大写格式
            if (lowerId.startsWith('ogs-')) {
                const num = lowerId.substring(4);
                return `images/OGS-${num}.png`;
            }
            // 其他使用小写
            return `images/${lowerId}.png`;
        }

        // 更新摘要
        function updateSummary() {
            const summary = document.getElementById('deckSummary');
            
            // 保存所有可滚动容器的滚动位置
            const scrollPositions = {};
            const scrollContainers = summary.querySelectorAll('.deck-cards-list');
            scrollContainers.forEach((container, index) => {
                scrollPositions[`list-${index}`] = container.scrollTop;
            });
            
            const totalCards = currentDeck.cards.reduce((sum, c) => sum + c.num, 0);
            const totalRunes = currentDeck.runes.reduce((sum, r) => sum + r.num, 0);
            const totalBattlefields = currentDeck.battlefield.reduce((sum, b) => sum + b.num, 0);
            
            let html = `
                <h3>卡组统计</h3>
                <div class="summary-item">传奇: ${currentDeck.legend ? currentDeck.legend.card_name : '未选择'}</div>
                <div class="summary-item">符文: ${totalRunes} 张</div>
                <div class="summary-item">战场: ${totalBattlefields} 张</div>
                <div class="summary-item">卡牌: ${totalCards} 张</div>
                <div class="summary-item">总计: ${totalCards + totalRunes + totalBattlefields + (currentDeck.legend ? 1 : 0)} 张</div>
            `;
            
            // 显示符文详情
            if (currentDeck.runes.length > 0) {
                html += `<div class="deck-cards-section">
                    <h4>符文 (${totalRunes} 张)</h4>
                    <div class="deck-cards-list" data-section="runes">`;
                currentDeck.runes.forEach(rune => {
                    html += `
                        <div class="deck-card-item">
                            <img src="${getImagePath(rune.card_id)}" alt="${rune.card_name}" onclick="showCardDetailById('${rune.card_id}', 'rune')" onerror="this.src='data:image/svg+xml,<svg xmlns=\\'http://www.w3.org/2000/svg\\' width=\\'60\\' height=\\'84\\'><rect fill=\\'%23ccc\\'/></svg>'">
                            <div class="card-info-text">
                                <div class="card-name-text">${rune.card_name}</div>
                                <div class="card-type-text">${rune.card_type} - ${rune.color.join(', ')}</div>
                            </div>
                            <input type="number" min="0" max="12" value="${rune.num}" onchange="updateRuneCountFromSummary('${rune.card_id}', parseInt(this.value) || 0)">
                        </div>
                    `;
                });
                html += `</div></div>`;
            }
            
            // 显示战场详情
            if (currentDeck.battlefield.length > 0) {
                html += `<div class="deck-cards-section">
                    <h4>战场 (${totalBattlefields} 张)</h4>
                    <div class="deck-cards-list" data-section="battlefield">`;
                currentDeck.battlefield.forEach(battlefield => {
                    html += `
                        <div class="deck-card-item battlefield-summary-item">
                            <img class="battlefield-image" src="${getImagePath(battlefield.card_id)}" alt="${battlefield.card_name}" onclick="showCardDetailById('${battlefield.card_id}', 'battlefield')" onerror="this.src='data:image/svg+xml,<svg xmlns=\\'http://www.w3.org/2000/svg\\' width=\\'60\\' height=\\'84\\'><rect fill=\\'%23ccc\\'/></svg>'">
                            <div class="card-info-text">
                                <div class="card-name-text">${battlefield.card_name}</div>
                                <div class="card-type-text">${battlefield.card_type} (${battlefield.num} 张)</div>
                            </div>
                            <button class="remove-btn" onclick="removeBattlefieldFromSummary('${battlefield.card_id}')">移除</button>
                        </div>
                    `;
                });
                html += `</div></div>`;
            }
            
            // 显示卡牌详情
            if (currentDeck.cards.length > 0) {
                html += `<div class="deck-cards-section">
                    <h4>卡牌 (${totalCards} 张)</h4>
                    <div class="deck-cards-list" data-section="cards">`;
                currentDeck.cards.forEach(card => {
                    html += `
                        <div class="deck-card-item">
                            <img src="${getImagePath(card.card_id)}" alt="${card.card_name}" onclick="showCardDetailById('${card.card_id}', 'card')" onerror="this.src='data:image/svg+xml,<svg xmlns=\\'http://www.w3.org/2000/svg\\' width=\\'60\\' height=\\'84\\'><rect fill=\\'%23ccc\\'/></svg>'">
                            <div class="card-info-text">
                                <div class="card-name-text">${card.card_name}</div>
                                <div class="card-type-text">${card.card_type}${card.color.length > 0 ? ' - ' + card.color.join(', ') : ''}</div>
                            </div>
                            <input type="number" min="0" max="3" value="${card.num}" onchange="updateCardCountFromSummary('${card.card_id}', parseInt(this.value) || 0)">
                            <button class="remove-btn" onclick="removeCardFromSummary('${card.card_id}')">移除</button>
                        </div>
                    `;
                });
                html += `</div></div>`;
            }
            
            summary.innerHTML = html;
            
            // 恢复滚动位置（使用双重requestAnimationFrame确保DOM已完全渲染）
            requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    const newScrollContainers = summary.querySelectorAll('.deck-cards-list');
                    newScrollContainers.forEach((container, index) => {
                        const key = `list-${index}`;
                        if (scrollPositions[key] !== undefined) {
                            container.scrollTop = scrollPositions[key];
                        }
                    });
                });
            });
            
            validateDeck();
            document.getElementById('summarySection').style.display = 'block';
            document.getElementById('saveSection').style.display = 'block';
        }
        
        // 从摘要更新符文数量
        function updateRuneCountFromSummary(cardId, count) {
            const rune = allRunes.find(r => r.card_id === cardId);
            if (rune) {
                updateRuneCount(rune, count);
            }
        }
        
        // 从摘要更新战场数量
        function updateBattlefieldCountFromSummary(cardId, count) {
            const battlefield = allBattlefields.find(b => b.card_id === cardId);
            if (battlefield) {
                const index = currentDeck.battlefield.findIndex(b => b.card_id === cardId);
                if (count > 0 && count <= 3) {
                    if (index >= 0) {
                        currentDeck.battlefield[index].num = count;
                    } else {
                        currentDeck.battlefield.push({ ...battlefield, num: count });
                    }
                } else if (count === 0) {
                    if (index >= 0) {
                        currentDeck.battlefield.splice(index, 1);
                    }
                }
                renderBattlefields();
                updateSummary();
            }
        }
        
        // 从摘要移除战场
        function removeBattlefieldFromSummary(cardId) {
            const index = currentDeck.battlefield.findIndex(b => b.card_id === cardId);
            if (index >= 0) {
                currentDeck.battlefield.splice(index, 1);
                renderBattlefields();
                updateSummary();
            }
        }
        
        // 从摘要更新卡牌数量
        function updateCardCountFromSummary(cardId, count) {
            const card = allCards.find(c => c.card_id === cardId);
            if (card) {
                const index = currentDeck.cards.findIndex(c => c.card_id === cardId);
                if (count > 0 && count <= 3) {
                    if (index >= 0) {
                        currentDeck.cards[index].num = count;
                    } else {
                        currentDeck.cards.push({ ...card, num: count });
                    }
                } else if (count === 0) {
                    if (index >= 0) {
                        currentDeck.cards.splice(index, 1);
                    }
                }
                // 保持筛选状态，只重新渲染列表而不重新筛选
                renderCardsList(currentDisplayedCards);
                updateSummary();
            }
        }
        
        // 从摘要移除卡牌
        function removeCardFromSummary(cardId) {
            const index = currentDeck.cards.findIndex(c => c.card_id === cardId);
            if (index >= 0) {
                currentDeck.cards.splice(index, 1);
                // 保持筛选状态，只重新渲染列表而不重新筛选
                renderCardsList(currentDisplayedCards);
                updateSummary();
            }
        }

        // 验证卡组
        function validateDeck() {
            const message = document.getElementById('validationMessage');
            const errors = [];
            
            // 检查传奇
            if (!currentDeck.legend) {
                errors.push('请选择传奇');
            }
            
            // 检查符文
            if (currentDeck.runes.length !== 2) {
                errors.push('必须选择2种符文');
            }
            const runeTotal = currentDeck.runes.reduce((sum, r) => sum + (parseInt(r.num, 10) || 0), 0);
            if (runeTotal !== 12) {
                errors.push(`符文总数必须为12张，当前为${runeTotal}张`);
            }
            
            // 检查战场
            const totalBattlefields = currentDeck.battlefield.reduce((sum, b) => sum + b.num, 0);
            if (totalBattlefields < 1) {
                errors.push('至少需要1张战场');
            } else if (totalBattlefields > 3) {
                errors.push('战场不能超过3张');
            }
            
            // 检查卡牌数量
            const totalCards = currentDeck.cards.reduce((sum, c) => sum + c.num, 0);
            if (totalCards !== 40) {
                errors.push(`卡牌数量必须为40张，当前为${totalCards}张`);
            }
            
            // 检查每张卡牌数量
            currentDeck.cards.forEach(card => {
                if (card.num > 3) {
                    errors.push(`卡牌 ${card.card_name} 不能超过3张`);
                }
            });
            
            // 检查专属卡牌
            if (selectedLegend) {
                // 获取传奇名称，支持多种格式
                const legendName = selectedLegend.legend || selectedLegend['所属传奇'] || selectedLegend.card_name.split('-')[0];
                currentDeck.cards.forEach(card => {
                    if (card.card_type === '专属法术' || card.card_type === '专属单位') {
                        // 支持两种字段名：legend（英文）和所属传奇（中文）
                        const cardLegend = card.legend || card['所属传奇'];
                        if (cardLegend && cardLegend !== legendName) {
                            errors.push(`专属卡牌 ${card.card_name} 不属于当前传奇`);
                        }
                    }
                });
            }
            
            // 检查颜色匹配
            if (selectedLegend) {
                const legendColors = selectedLegend.color;
                currentDeck.cards.forEach(card => {
                    if (card.card_type !== '专属法术' && card.card_type !== '专属单位') {
                        if (card.color.length === 1) {
                            if (!legendColors.includes(card.color[0])) {
                                errors.push(`卡牌 ${card.card_name} 颜色不匹配`);
                            }
                        } else if (card.color.length === 2) {
                            if (!card.color.every(c => legendColors.includes(c))) {
                                errors.push(`卡牌 ${card.card_name} 颜色不匹配`);
                            }
                        }
                    }
                });
            }
            
            if (errors.length === 0) {
                message.className = 'validation-message success';
                message.textContent = '✓ 卡组验证通过！';
            } else {
                message.className = 'validation-message error';
                message.innerHTML = '✗ 验证失败:<br>' + errors.join('<br>');
            }
        }

        // 清理卡牌数据，只保留必要字段
        function cleanCardData(card, cardType) {
            const cleaned = {
                num: card.num,
                card_id: card.card_id,
                card_name: card.card_name,
                color: card.color,
                card_type: card.card_type
            };
            
            // 根据卡牌类型添加特定字段
            if (cardType === 'legend') {
                // 传奇需要 legend_belongto 字段
                const legendName = card.legend || card['所属传奇'] || card.card_name.split('-')[0];
                if (legendName) {
                    cleaned.legend_belongto = legendName;
                }
            } else if (cardType === 'card') {
                // 卡牌如果是专属类型，需要 legend_belongto 字段
                if (card.card_type === '专属法术' || card.card_type === '专属单位' || card.card_type === '英雄单位') {
                    const legendName = card.legend || card['所属传奇'];
                    if (legendName) {
                        cleaned.legend_belongto = legendName;
                    }
                }
            }
            // 符文和战场不需要额外字段
            
            return cleaned;
        }

        // 保存卡组
        function saveDeck() {
            const deckName = document.getElementById('deckName').value.trim();
            const fileName = document.getElementById('fileName').value.trim();
            
            if (!deckName) {
                alert('请输入卡组名称');
                return;
            }
            
            if (!fileName) {
                alert('请输入文件名');
                return;
            }
            
            // 清理和格式化卡组数据
            const cleanedDeck = {
                deck_name: deckName,
                legend: currentDeck.legend ? cleanCardData(currentDeck.legend, 'legend') : null,
                runes: currentDeck.runes.map(rune => cleanCardData(rune, 'rune')),
                battlefield: currentDeck.battlefield.map(battlefield => cleanCardData(battlefield, 'battlefield')),
                cards: currentDeck.cards.map(card => cleanCardData(card, 'card'))
            };
            
            const json = JSON.stringify(cleanedDeck, null, 4);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            // 使用文件名作为下载文件名，移除可能包含的扩展名
            const cleanFileName = fileName.replace(/\.json$/i, '');
            a.download = `${cleanFileName}.json`;
            a.click();
            URL.revokeObjectURL(url);
            
            alert('卡组保存成功！');
        }
    </script>
</body>
</html>

